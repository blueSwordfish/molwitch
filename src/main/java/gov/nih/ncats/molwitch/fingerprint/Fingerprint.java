/*
 * NCATS-MOLWITCH
 *
 * Copyright 2024 NIH/NCATS
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package gov.nih.ncats.molwitch.fingerprint;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Objects;
import java.util.OptionalDouble;

/**
 * Class that represents a "fingerprint" for
 * a single {@link gov.nih.ncats.molwitch.Chemical} generated by a Fingerprinter.
 * 
 * @author katzelda
 *
 */
public class Fingerprint {

	private static final OptionalDouble OPTION_DOUBLE_EXACT_MATCH = OptionalDouble.of(1D);
	/**
	 * Create a new Fingerprint instance from the given binary
	 * String.  The leftmost position is the most significant bit so
	 * {@code 10010100} will have a fingerprint with 1's on at
	 * {@code 2, 4, 7}.
	 * @param fp the fingerprint as a binary string; can not be null.
	 * @return a new Fingerprint object
	 * @throws NullPointerException if fp is null
	 */
	public static Fingerprint fromBinaryString(String fp) {
		return new Fingerprint(fromString(fp), fp.trim().length());
	}
	
	private static BitSet fromString(String binary) {
	    BitSet bitset = new BitSet(binary.length());
	    int len = binary.length();
	    for (int i = len-1; i >= 0; i--) {
	        if (binary.charAt(i) == '1') {
	            bitset.set(len-i-1);
	        }
	    }
	    return bitset;
	}
	/**
	 * our internal fingerprint storage is a BitSet
	 * for its compact-ness and ease of logical operations.
	 */
	private final BitSet bits;
	/**
	 * Number of bits stored for this fingerprint (this may be different than the Bitset length).
	 */
	private final int bitLength;
	
	/**
	 * Create a new fingerprint object for the given bitset and the length of this fingerprint.
	 *
	 * 
	 * @param bits the {@link BitSet} of this fingerprint.
	 * @param bitLength the length of this fingerprint.  The bitlength should always be
	 *                  &ge; the highest set bit in the given bitset.
	 * @throws NullPointerException if bits is null.
	 * @throws IllegalArgumentException if bitLength is &lt; 1.
	 */
	public Fingerprint(BitSet bits, int bitLength) {
		if(bitLength <1){
			throw new IllegalArgumentException("bitLength must be >=1");
		}
		this.bitLength = bitLength;
		this.bits = Objects.requireNonNull(bits);
	}
	/**
	 * Create a new fingerprint object for the given byte array.
	 * 
	 * @param bytes the byte array of this fingerprint.
	 */
	public Fingerprint(byte[] bytes) {

		this.bitLength = bytes.length *8;
		this.bits = BitSet.valueOf(bytes);
	}
	/**
	 * Perform a logical AND operation between this
	 * Fingerprint and the other given fingerprint,
	 * The result is then returned as a new Fingerprint.
	 * This operation does no modify either input fingerprints.
	 * 
	 * @param other the other {@link Fingerprint} to AND;
	 * can not be null.
	 * @return a new {@link Fingerprint} containing the result.
	 * 
	 * @throws NullPointerException if other is null.
	 */
	public Fingerprint and(Fingerprint other){
		//work off of a copy since
		//the and() operation on BitSet modifies 
		BitSet result = copyOfBitset();
		result.and(other.bits);
		int andedLength = Math.max(bitLength, other.bitLength);
		return new Fingerprint(result, andedLength);
	}
	
	/**
	 * Is this fingerprint "compatible" with the other given fingerprint.
	 * Compatibility is defined as having both fingerprints have 1s set
	 * where this fingerprint has a 1 set.
	 * 
	 * @param other the other fingerprint to compare to; can not be null.
	 * 
	 * @return {@code true} if these fingerprints are compatible; {@code false} otherwise.
	 * 
	 * @throws NullPointerException if other is null.
	 */
	public boolean compatible(Fingerprint other){
		BitSet otherbits = other.bits;
		
		for(int i=bits.nextSetBit(0); i>=0; i = bits.nextSetBit(i+1) ){
			 // operate on index i here
		     if (i == Integer.MAX_VALUE) {
		         break; // or (i+1) would overflow
		     }
			
			if(!otherbits.get(i)){
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Get the Population count of this fingerprint which is
	 * the number of bits set to {@code true} in this fingerprint.
	 * 
	 * @return the number of bits set to {@code true} in this fingerprint.
	 */
	public int populationCount(){
		return bits.cardinality();
	}
	/**
	 * Convert this fingeprint into a byte array.
	 * @return a new byte array.
	 */
	public byte[] toByteArray(){
		//can't just use BitSet#toByteArray()
		//because that only populates up to the highest set bit
		//so each call won't be a consistent size
		//even for the same FingerPrinter implementation
		//with the same parameters but different Chemical.
		
		//so make a full length byte array
		//and then copy the contents from the bitset into it.
		//this should then include the correct amount of trailing zeroes.
		byte[] bytes = new byte[bitLength/8];
		byte[] bitsetBytes = bits.toByteArray();
		System.arraycopy(bitsetBytes, 0, bytes, 0, Math.min(bitsetBytes.length, bytes.length));
		return bytes;
	}
    /**
     * Convert this fingeprint into a byte array.
     * @return a new byte array.
     */
	public int[] toIntArray(){
        int[] temp = new int[bitLength / 32];

        for (int i = 0; i < temp.length; i++) {
            for (int j = 0; j < 32; j++) {
                if (bits.get(i * 32 + j)) {
                    temp[i] |= 1 << j;
                }
            }
        }

        return temp;
    }
	/**
	 * Convert this fingerprint to a {@link BitSet}.
	 * Please note, the returned BitSet may have different lengths
	 * and sizes depending on what bits are set in the fingerprint.
	 * 
	 * @return the {@link BitSet}; will never be null.
	 */
	public BitSet toBitSet() {
		return copyOfBitset();
		
	}

	private BitSet copyOfBitset() {
		return (BitSet) bits.clone();
	}
	/**
	 * Get the hamming distance between this {@link Fingerprint}
	 * and the given other {@link Fingerprint}.  This can
	 * be thought of as the minimum number of bits to flip to convert
	 * from one Fingerprint into the other.
	 * 
	 * @param other the other {@link Fingerprint} to find the hamming distance between;
	 * can not be null.
	 * @return the hamming distance as an int.
	 */
	public int hammingDistance(Fingerprint other){
		//work off of a copy since
		//the and() operation on BitSet modifies 
		BitSet result = copyOfBitset();
		result.xor(other.bits);
		
		return result.cardinality();
	}
	/**
	 * Compute the Tanimoto Similarity (also known as
	 * Jaccard Index or Jaccard Similarity Coefficient) 
	 * which measures how similar this {@link Fingerprint} is
	 * compared to the other given {@link Fingerprint}.
	 * 
	 * @param other the other {@link Fingerprint} to compare to; can not be null.
	 * 
	 * @return  a double between {@code 0} and {@code 1} where 
	 * two identical fingerprints will return {@code 1}.
	 * 
	 * @throws NullPointerException if other is null.
	 */
	public double tanimotoSimilarity(Fingerprint other){
		
		BitSet and = copyOfBitset();
		and.and(other.bits);
		
		BitSet or = copyOfBitset();
		 or.or(other.bits);
		
		//jaccard index is M(11) / (M01 + M10 + M11)
		int orCardinality = or.cardinality();
		if(orCardinality ==0){
			//avoid divide by 0
			return 1D;
		}
		return and.cardinality() / (double)orCardinality;
		
	}
	
	/**
	 * Compute the Tanimoto Similarity (also known as
	 * Jaccard Index or Jaccard Similarity Coefficient) 
	 * which measures how similar this {@link Fingerprint} is
	 * compared to the other given {@link Fingerprint}
	 * except the method will short circuit and return {@code OptionalDouble.empty()}
	 * if this fingerprint logical and'ed to the other fingerprint
	 * don't have the same value.  This will make calculations that are probably
	 * not similar enough to end early.
	 * 
	 * @param other the other {@link Fingerprint} to compare to; can not be null.
	 * 
	 * @return  an {@link OptionalDouble} between {@code 0} and {@code 1} of {@code empty}
	 * if the fingerprints are too dissimilar. Two identical fingerprints will return {@code 1}.
	 * 
	 * @throws NullPointerException if other is null.
	 */
	public OptionalDouble tanimotoSimilarityShortCircuit(Fingerprint other){
		
		BitSet and = copyOfBitset();
		and.and(other.bits);
		
		if(!bits.equals(and)){
			return OptionalDouble.empty();
		}
		
		BitSet or = copyOfBitset();
		 or.or(other.bits);
		
		//jaccard index is M(11) / (M01 + M10 + M11)
		int orCardinality = or.cardinality();
		if(orCardinality ==0){
			//avoid divide by 0
			return OPTION_DOUBLE_EXACT_MATCH;
		}
		return OptionalDouble.of(and.cardinality() / (double)orCardinality);
		
	}
	/**
	 * Compute the Jaccard Distance to the  other given {@link Fingerprint}.
	 * 
	 * @param other the other {@link Fingerprint} to compare to; can not be null.
	 * 
	 * @return The distance which is defined as {@code 1- tanimotoSimilarity(other)}.
	 * 
	 * @throws NullPointerException if other is null.
	 */
	public double jaccardDistanceTo(Fingerprint other){
		return 1 - tanimotoSimilarity(other);
	}
	
	/**
	 * Get the number of bits in this fingerprint (some might not be set).
	 * @return the length.
	 */
	public int getLength() {
		return bitLength;
	}
	@Override
	public int hashCode() {
		return Arrays.hashCode(toByteArray());
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Fingerprint other = (Fingerprint) obj;
		return Arrays.equals(toByteArray(), other.toByteArray());
	}
	@Override
	public String toString() {
		return "Fingerprint [bits=" + bits + "]";
	}
	
	
	
}
